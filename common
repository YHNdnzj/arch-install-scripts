#!/hint/bash
# shellcheck disable=SC2155,SC2064

# generated from util-linux source: libmount/src/utils.c
declare -A pseudofs_types=([anon_inodefs]=1
                           [apparmorfs]=1
                           [autofs]=1
                           [bdev]=1
                           [binder]=1
                           [binfmt_misc]=1
                           [bpf]=1
                           [cgroup]=1
                           [cgroup2]=1
                           [configfs]=1
                           [cpuset]=1
                           [debugfs]=1
                           [devfs]=1
                           [devpts]=1
                           [devtmpfs]=1
                           [dlmfs]=1
                           [dmabuf]=1
                           [drm]=1
                           [efivarfs]=1
                           [fuse]=1
                           [fuse.archivemount]=1
                           [fuse.avfsd]=1
                           [fuse.dumpfs]=1
                           [fuse.encfs]=1
                           [fuse.gvfs-fuse-daemon]=1
                           [fuse.gvfsd-fuse]=1
                           [fuse.lxcfs]=1
                           [fuse.rofiles-fuse]=1
                           [fuse.vmware-vmblock]=1
                           [fuse.xwmfs]=1
                           [fusectl]=1
                           [hugetlbfs]=1
                           [ipathfs]=1
                           [mqueue]=1
                           [nfsd]=1
                           [none]=1
                           [nsfs]=1
                           [overlay]=1
                           [pipefs]=1
                           [proc]=1
                           [pstore]=1
                           [ramfs]=1
                           [resctrl]=1
                           [rootfs]=1
                           [rpc_pipefs]=1
                           [securityfs]=1
                           [selinuxfs]=1
                           [smackfs]=1
                           [sockfs]=1
                           [spufs]=1
                           [sysfs]=1
                           [tmpfs]=1
                           [tracefs]=1
                           [vboxsf]=1
                           [virtiofs]=1)

# generated from: pkgfile -vbr '/fsck\..+' | awk -F. '{ print $NF }' | sort
declare -A fsck_types=([btrfs]=0    # btrfs doesn't need a regular fsck utility
                       [cramfs]=1
                       [erofs]=1
                       [exfat]=1
                       [ext2]=1
                       [ext3]=1
                       [ext4]=1
                       [f2fs]=1
                       [fat]=1
                       [jfs]=1
                       [minix]=1
                       [msdos]=1
                       [reiserfs]=1
                       [vfat]=1
                       [xfs]=1)

# shellcheck disable=SC2059
out() { printf "$1 $2\n" "${@:3}"; }
msg() { out "==>" "$@"; }
msg2() { out "  ->" "$@"; }
warning() { out "==> WARNING:" "$@"; } >&2
error() { out "==> ERROR:" "$@"; } >&2
die() { error "$@"; exit 1; }

ignore_error() {
  "$@" 2>/dev/null || return 0
}

in_array() {
  local i
  local -n _arr="$1"

  for i in "${_arr[@]}"; do
    [[ "$i" = "$1" ]] && return 0
  done

  return 1
}

rev_array() {
  local -n _arr="$1"

  mapfile -t _arr < <(printf '%s\n' "${_arr[@]}" | tac)
}

check_root() {
  (( EUID == 0 )) || die 'This script must be run with root privileges'
}

resolve_link() {
  local link="$1" root="$2" target

  if [[ ! $root ]]; then
    target="$(realpath -eq "$link")"
  else
    # This is tricky to do. We read from $link in a loop
    # and prepend it with $root if it's not under it.
    # This can't handle e.g. $root is /mnt and $link
    # is /mnt/1 pointing to /mnt/2, which should actually
    # be /mnt/mnt/2. Luckily these edge cases shouldn't
    # bother most of the time.

    root="$(realpath -e "$root")"
    target="$link"
    while [[ -L "$target" ]]; do
      target="$(readlink -m "$target")"
      if [[ "$target" != "$root"/* ]]; then
        target="$root/${target#/}"
      fi
    done

    # Normalize the path and make sure the resolved target exists
    target="$(realpath -eq "$target")"
  fi

  printf '%s' "$target"
}

chroot_add_mount() {
  mount "$@" && CHROOT_ACTIVE_MOUNTS+=("$2")
}

chroot_maybe_add_mount() {
  local cond="$1"; shift

  if eval "$cond"; then
    chroot_add_mount "$@"
  fi
}

chroot_add_mount_lazy() {
  mount "$@" && CHROOT_ACTIVE_LAZY+=("$2")
}

chroot_bind_device() {
  touch "$2" && CHROOT_ACTIVE_FILES+=("$2")
  chroot_add_mount "$1" "$2" --bind
}

chroot_add_link() {
  ln -sf "$1" "$2" && CHROOT_ACTIVE_FILES+=("$2")
}

chroot_add_resolv_conf() {
  local src="$(resolve_link /etc/resolv.conf)" dest="$1/etc/resolv.conf"

  # If we don't have a source resolv.conf file, there's nothing useful we can do.
  if [[ ! -f "$src" ]]; then
    warning 'Cannot find a usable resolv.conf. DNS requests might fail in chroot'
    return 0
  fi

  # If resolv.conf in the chroot is a symlink, we make a backup of it
  # and create a plain file so we can bind mount to it.
  # The backup is restore during chroot_teardown().

  if [[ -L "$dest" ]]; then
    mv "$dest" "$dest.orig"
  fi
  touch -a "$dest"

  chroot_add_mount "$src" "$dest" --bind
}

chroot_setup() {
  CHROOT_ACTIVE_MOUNTS=()
  local root="$1"
  local errtrap_old="$(trap -p ERR)" shellopts_old="$SHELLOPTS"

  [[ $(trap -p EXIT) ]] && die 'An EXIT trap already exists (likely a bug)'
  trap "chroot_teardown $root" EXIT

  trap "$errtrap_old; die 'Failed to setup chroot %s' '$root'" ERR
  set -e

  chroot_add_mount proc "$root"/proc -t proc -o nosuid,noexec,nodev
  chroot_add_mount sys "$root"/sys -t sysfs -o nosuid,noexec,nodev,ro
  ignore_error chroot_maybe_add_mount "[[ -d '$root/sys/firmware/efi/efivars' ]]" \
      efivarfs "$root"/sys/firmware/efi/efivars -t efivarfs -o nosuid,noexec,nodev
  chroot_add_mount udev "$root"/dev -t devtmpfs -o mode=0755,nosuid
  chroot_add_mount devpts "$root"/dev/pts -t devpts -o mode=0620,gid=5,nosuid,noexec
  chroot_add_mount shm "$root"/dev/shm -t tmpfs -o mode=1777,nosuid,nodev
  chroot_add_mount run "$root"/run -t tmpfs -o nosuid,nodev,mode=0755
  chroot_add_mount tmp "$root"/tmp -t tmpfs -o mode=1777,strictatime,nodev,nosuid

  [[ "$shellopts_old" = *'errexit'* ]] || set +e
  if [[ $errtrap_old ]]; then
    trap "$errtrap_old" ERR
  else
    trap - ERR
  fi
}

chroot_teardown() {
  local root="$1"

  if (( ${#CHROOT_ACTIVE_MOUNTS[@]} )); then
    rev_array CHROOT_ACTIVE_MOUNTS
    umount "${CHROOT_ACTIVE_MOUNTS[@]}"
  fi
  unset CHROOT_ACTIVE_MOUNTS

  if [[ -L "$root"/etc/resolv.conf.orig ]]; then
    mv "$root"/etc/resolv.conf.orig "$root"/etc/resolv.conf
  fi
}

unshare_setup() {
  CHROOT_ACTIVE_MOUNTS=() CHROOT_ACTIVE_LAZY=() CHROOT_ACTIVE_FILES=()
  local root="$1"
  local errtrap_old="$(trap -p ERR)" shellopts_old="$SHELLOPTS"

  [[ $(trap -p EXIT) ]] && die 'An EXIT trap already exists (likely a bug)'
  trap "unshare_teardown $root" EXIT

  trap "$errtrap_old; die 'Failed to setup chroot %s' '$root'" ERR
  set -e

  chroot_add_mount_lazy "$root" "$root" --bind
  chroot_add_mount proc "$root"/proc -t proc -o nosuid,noexec,nodev
  chroot_add_mount_lazy /sys "$root"/sys --rbind
  chroot_add_link "$root"/proc/self/fd "$root"/dev/fd
  chroot_add_link "$root"/proc/self/fd/0 "$root"/dev/stdin
  chroot_add_link "$root"/proc/self/fd/1 "$root"/dev/stdout
  chroot_add_link "$root"/proc/self/fd/2 "$root"/dev/stderr
  chroot_bind_device /dev/full "$root"/dev/full
  chroot_bind_device /dev/null "$root"/dev/null
  chroot_bind_device /dev/zero "$root"/dev/zero
  chroot_bind_device /dev/random "$root"/dev/random
  chroot_bind_device /dev/urandom "$root"/dev/urandom
  chroot_bind_device /dev/tty "$root"/dev/tty
  chroot_add_mount run "$root"/run -t tmpfs -o nosuid,nodev,mode=0755
  chroot_add_mount tmp "$root"/tmp -t tmpfs -o mode=1777,strictatime,nodev,nosuid

  [[ "$shellopts_old" = *'errexit'* ]] || set +e
  if [[ $errtrap_old ]]; then
    trap "$errtrap_old" ERR
  else
    trap - ERR
  fi
}

unshare_teardown() {
  chroot_teardown "$1"

  if (( ${#CHROOT_ACTIVE_LAZY[@]} )); then
    rev_array CHROOT_ACTIVE_LAZY
    umount --lazy "${CHROOT_ACTIVE_LAZY[@]}"
  fi
  unset CHROOT_ACTIVE_LAZY

  if (( ${#CHROOT_ACTIVE_FILES[@]} )); then
    rev_array CHROOT_ACTIVE_FILES
    rm "${CHROOT_ACTIVE_FILES[@]}"
  fi
  unset CHROOT_ACTIVE_FILES
}

pid_unshare="unshare --fork --pid"
# shellcheck disable=SC2034
mount_unshare="$pid_unshare --mount --map-auto --map-root-user --setuid 0 --setgid 0"

# This outputs code for declaring all variables to stdout. For example, if
# FOO=BAR, then running
#     declare -p FOO
# will result in the output
#     declare -- FOO="bar"
# This function may be used to re-declare all currently used variables and
# functions in a new shell.
declare_all() {
  # Remove read-only variables to avoid warnings. Unfortunately, declare +r -p
  # doesn't work like it looks like it should (declaring only read-write
  # variables). However, declare -rp will print out read-only variables, which
  # we can then use to remove those definitions.
  declare -p | grep -Fvf <(declare -rp)
  # Then declare functions
  declare -pf
}

try_cast() (
  _=$(( ${1#"$2"} ))
) 2>/dev/null

valid_number_of_base() {
  local base="$1" len="${#2}" i

  for (( i = 0; i < len; i++ )); do
    try_cast "$base" "${2:i:1}" || return 1
  done

  return 0
}

mangle() {
  local i chr out
  local {a..f}='' {A..F}=''

  for (( i = 0; i < ${#1}; i++ )); do
    chr="${1:i:1}"
    case $chr in
      [[:space:]\\])
        printf -v chr '%03o' "'$chr"
        out+=\\
        ;;
    esac
    out+="$chr"
  done

  printf '%s' "$out"
}

unmangle() {
  local i chr out len="$(( ${#1} - 4 ))"
  local {a..f}='' {A..F}=''

  for (( i = 0; i < len; i++ )); do
    chr="${1:i:1}"
    case $chr in
      \\)
        if valid_number_of_base 8 "${1:i+1:3}" ||
            valid_number_of_base 16 "${1:i+1:3}"; then
          printf -v chr '%b' "${1:i:4}"
          (( i += 3 ))
        fi
        ;;
    esac
    out+="$chr"
  done

  printf '%s' "$out${1:i}"
}

optstring_match_one_option() {
  local options=() target="$2"
  local -n _optstring_match="$1"

  IFS=, read -ra options <<<"$_optstring_match"
  if [[ "$target" != *'='* ]]; then
    options=("${options[@]%%=*}")
  fi

  in_array options "$target"
}

optstring_get_options() {
  local i options=()
  local -n _ret="$1" _optstring_get="$2"
  local -i got=0

  IFS=, read -ra options <<<"$_optstring_get"

  shift 2
  for i in "${!options[@]}"; do
    if optstring_match_one_option 'options[i]' "$1"; then
      _ret+=(["${options[i]%%=*}"]="${options[i]//*=}")
      got=1
    fi
    shift || break
  done

  (( got ))
}

optstring_from_array() {
  local optstring
  local -n _optarray="$1"

  optstring="$(printf ',%s' "${_optarray[@]}")"
  optstring="${optstring:1}" # Remove the leading comma

  printf '%s' "$optstring"
}

optstring_normalize() {
  local i options=()
  local -n _optstring_norm="$1"

  IFS=, read -ra options <<<"$_optstring_norm"

  # remove empty fields
  for i in "${!options[@]}"; do
    [[ ${options[i]} ]] || unset 'options[i]'
  done

  # avoid empty strings, reset to "defaults"
  if (( ! ${#options[@]} )); then
    _optstring_norm="defaults"
  else
    _optstring_norm="$(optstring_from_array options)"
  fi
}

optstring_remove_options() {
  local i options=() target="$2"
  local -n _optstring_remove="$1"

  IFS=, read -ra options <<<"$_optstring_remove"

  for i in "${!options[@]}"; do
    optstring_match_one_option 'options[i]' "$target" && unset 'options[i]'
  done

  _optstring_remove="$(optstring_from_array options)"
}

optstring_append_one_option() {
  local option="$2"
  local -n _optstring_append="$1"

  if ! optstring_match_one_option _optstring_append "$option"; then
    _optstring_append+=",$option"
  fi

  optstring_normalize _optstring_append
}

optstring_prepend_one_option() {
  local option="$2"
  local -n _optstring_prepend="$1"

  if ! optstring_match_one_option _optstring_prepend "$option"; then
    _optstring_prepend="$option,$_optstring_prepend"
  fi

  optstring_normalize _optstring_prepend
}

dm_name_for_devnode() {
  read -r dm_name <"/sys/class/block/${1#/dev/}/dm/name"
  if [[ $dm_name ]]; then
    printf '/dev/mapper/%s' "$dm_name"
  else
    # don't leave the caller hanging, just print the original name
    # along with the failure.
    error 'Failed to resolve device mapper name for: %s' "$1"
  fi
}

fstype_is_pseudofs() {
  (( pseudofs_types["$1"] )) || findmnt --pseudo "$1" &>/dev/null
}

fstype_has_fsck() {
  (( fsck_types["$1"] == 0 )) && return 1
  (( fsck_types["$1"] )) || command -v "fsck.$1" &>/dev/null
}

# vim: et ts=2 sw=2 ft=sh:
